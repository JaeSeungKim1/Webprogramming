/*
        INSERT INTO <TABLE_NAME>(COL1, COL2,...)
        VALUES(VAL1, VAL2,...)
*/
SELECT * FROM EMP;
SELECT * FROM DEPT;
DESC EMP;
INSERT INTO EMP
VALUES(7701,'JW KANG','MANAGER',7839,
    TO_DATE('2023-01-01','YYYY-MM-DD'),3000,NULL,20);

    
INSERT INTO DEPT
VALUES(50,'SECURITY','SEOUL');

INSERT INTO EMP(JOB,ENAME,SAL,EMPNO)
VALUES('CLEARK','RONALDO',100,7702);
/*
    SELECT COL1, COL2,...       구분하는 CLASS명
    FROM <TABLE_NAME>;
    WHERE CONDITION
    ORDER BY COL1,COL2 ASC|DESC;
    LIKE        해당하는 것을 찾아주는 것
    MAX, MIN
    NULL FUNCTION
    ROLLUP
*/
SELECT EMPNO,JOB,MGR,ENME,SAL,COMN
FROM EMP;
SELECT * FROM EMP;
SELECT DISTINCT JOB FROM EMP;
SELECT * FROM EMP
WHERE JOB<>'CLERK';/*CLERK인 직업을 가진 사람만 뽑아낸다*/
-- = > < >= <= <>!=  BETWEEN LIKE IN
-- AND OR NOT
SELECT * FROM EMP
WHERE NOT JOB='CLERK';/*CLOCK이 없는 조건*/
AND SAL>=3000;
SELECT * FROM EMP
WHERE JOB='CLERK'
OR JOB = 'MANAGER'
AND SAL>=3000;

SELECT * FROM EMP
ORDER BY JOB DESC, ENAME DESC; /*두가지를 같이 적어서 JOB을 통해서 내림차순으로 정의 하고, 그 안에서 이름으로 내림차순 하겟다*/
SELECT DISTINCT JOB FROM EMP
ORDER BY JOB;
SELECT * FROM EMP
WHERE SAL BETWEEN 1300 AND 3000; /*1300~3000사이의 값을 뽑아내기 위한 값*/
SELECT * FROM EMP
WHERE JOB IN('CLERK','MANAGER'); /*CLERK, MANAGER의 직업을 가진 이들만 추려서 뽑아내는 것*/

SELECT ENAME FROM EMP
WHERE SAL<1500;
                /*위, 아래의 값이 똑같은 값을 나타냄*/
SELECT * FROM EMP
WHERE ENAME IN(
    SELECT ENAME FROM EMP
    WHERE SAL<1500);

--LIKE % 0,1,여러개인 문자 _ 하나의 문자
SELET ENAME FROM EMP
WHERE ENAME LIKE 'S%';  /* % ->  와일드카드 ,  '%_A% = WARD 같이 앞에 한글자가 들어가고 A가 오는 것을 찾겟다는 의미*/
/*
        UPDATE <TABLE_NAME>             
        SET COL1=VAL1, COL2=VAL2....
        WHERE CONDITION;
*/
UPDATE EMP
SET JOB = 'MANAGER',SAL=NULL   /*->이렇게만 바꾸면 모든이의 잡이 MANAGER로 SAL값은 전부다 NULL*/
WHERE EMPNO=7702;                   /*조건식이 없으면 모든이 적용// 그래서 원하는 이 선택해서 적용하면 그 사람만 적용*/
SELECT * FROM EMP WHERE EMPNO = 7702;

UPDATE EMP
SET COMM=100        /*7701인 사람의 커밋을 100을 주겟다*/
WHERE EMPNO=7701;
/*
        DELETE FROM <TABLE_NAME>
        WHERE CONDITION;
*/
DELETE FROM EMP
WHERE EMPNO=7702;  /*7702라는 정보를 EMP에서 완전히 없애겟다는 의미*/
SELECT * FROM EMP;
/*계산 함수
    MIN() MAX() COUNT() AVG() SUM()
*/
SELECT COUNT(*) AS 개수 FROM EMP
WHERE SAL>=3000;            /*3000보다 큰 사람이 몇명이니?*/
SELECT E.ENAME 이름,E.SLA 급여 FROM EMP E; /* EMP.ENAME, .EMP 한글로 예시 들 일은 거의 없다*/
SELECT MAX(SAL),  MIN(SAL), MAX(ENAME)
FROM EMP;   
SELECT AVG(SAL), SUM(SAL)
FROM EMP;

/* GROUP BY
    SELECT COLS(COUNT MAX MIN SUM AVG)
    FROM <TABLE_NAME>
    WHERE CONDITION
    GROUP BY <COLS>
    HAVING CONDITION
    ORDER BY <COLS>
    LISTAGG(한칸에다가 한줄로 보여주기)
*/
SELECT JOB,COUNT(*),MAX(SAL),MIN(SAL),AVG(SAL),SUM(SAL)  /*개별개별 그룹이 묶인게 JOB으로 표현    그룹의 전체 평균, 그룹의 전체 합...*/
FROM EMP
/*WHERE MIN(SAL)>1000;        이렇게만 하면 조건절이기 때문에 ERR이 나옴*/
GROUP BY JOB
HAVING MIN(SAL)>1000;                 /*왜냐하면 GROUP BY JOB에 대한 값이 없어서?*/

SELECT JOB,COUNT(*),MAX(SAL),MIN(SAL),AVG(SAL),SUM(SAL)
FROM EMP
GROUP BY JOB
HAVING MAX(COMM) IS NULL
ORDER BY JOB;

/* CASE */
SELECT ENAME,DEPTNO,COMM
    ,CASE
        WHEN SAL>2000 THEN '고연봉자'
        WHEN SAL>=1000 THEN '평균연봉자'
        ELSE '저연봉자'
    END AS STATE    /*스크립트 출력 시 주소값이 보이는걸 없애주는 것?*/
FROM EMP;

SELECT ENAME,SAL
FROM EMP
WHERE JOB=(CASE 
        WHEN SAL<1000 THEN 'CLERK'
        WHEN SAL>2000 THEN 'MANAGER'
        ELSE 'BOSS'     /*1600인 MANAGER이 오면 보스가 아니기 때문에 출력이 안됌*/
        END);   

/* NULL FUNCTION
    DB NVL() COALESECE()
*/
SELECT ENANE,SAL,COMM
    ,SAL+NVL(COMM,0) AS PAY /*해당된 SAL은 800 COMM이 0일 때 그대로 800+0 COMM이 300일 시 800+300=1100 COMMITION*/ 
    ,SAL+COALESECE(COMM,0) AS PAY2
FROM EMP;
---======================================================================================
SELECT DEPTNO,JOG,COUNT(*),MAX(SAL),SUM(SAL),AVG(SAL)
FROM EMP
/*GROUP BY DEPTNO,JOB
ORDER BY DEPTNO,JOB;*/
GROUP BY CUBE(DEPTNO,JOB)
GROUP BY ROLLUP(DEPTNO,JOB);  /*각 항목별로 정의해 놓은 값을 다 더해서 구한 값*/

===============================================================
-- TRUNC(VALUE,OPTION) TIME NUMBER
/*SELECT BEPTNO
  ,AVG(SAL)
    ,MAX(SAL)
    ,MIN(SAL)
    ,COUNT(*)
*/
SELECT NVL(TO_CHAR(DEPTNO),'부서없음')AS DEPT  /**/
    ,NVL(TRUNC(AVG(SAL)),1) AS AVG_SAL
    ,NVL(MAX(SAL),0) AS MAX_SAL
    ,NVL(MIN(SAL),0) AS MIN_SAL
    ,COUNT(*) AS CNT
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
SELECT * FROM EMP;
INSERT INTO EMP(EMPNO)
VALUES(7703);   /*결과값이 NULL이 나와을때*/
--FROM DUAL
SELECT SYSDATE FROM DUAL;
--3명 이상 존재하는 직급
SELECT JOB,COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(*)>=3; 
--각 인사년도별 부서별 입사자 수
SELECT HIREDATE
    ,DEPTNO
    ,COUNT(*)
FROM EMP
WHERE DEPTNO IS NOT NULL
GROUP BY TO_CHAR(HIREDATE, 'YYYY'),DEPTNO;
 --NVL2(COL,RES1 NO, RES2 YEW)
 SELECT NVL2(COMM, 'O','X')
    ,COUNT(*)
FROM EMP
GROUP BY NVL2(COMM, 'O','X');

--CREATE INSERT SELECT 활용
DROP TABLE SAL_DDL;
DROP TABLE SAL_DML;
DROP TABLE SAL_
CREATE TABLE SAL_DDL AS 
AS SELECT * FROM SALGRADE WHERE 1<>1;

INSERT INTO SAL_DDL(GRADE,LOSAL)
SELECT GRADE,LOSAL
FROM SALGRADE
WHERE GRADE=2;

INSERT INTO SAL_DDL(GRADE,LOSAL)
SELECT GRADE,LOSAL
FROM SALGRADE
WHERE GRADE=2;
INSERT INTO SAL_DDL(GRADE,HISAL)
SELECT 3,1000 FROM DUAL;

SELECT GRADE, LOSAL,HISAL   
FROM SALGRADE;

--CREATE INSERT SELECT 활용
SELECT * FROM SAL_DML;
SELECT * FROM SAL_TCL;
SELECT * FROM SAL_DDL;
CREATE TABLE SAL_DDL AS SELECT * FROM SALGRADE SHERE 1<>1;
CREATE TABLE SAL_TCL AS SELECT * FROM SALGRADE SHERE 1<>1;
CREATE TABLE SAL_DML AS SELECT * FROM SALGRADE SHERE 1<>1;
INSERT ALL
    WHEN LOSAL>=2001 THEN
        INTO SAL_DML VALUES(GRADE,LOSAL,HISAL)
    WHEN LOSAL>=1000 THEN
        INTO SAL_TCL VALUES(GRADE,LOSAL,HISAL)
    ELSE
        INTO SAL_DDL VALUES(GRADE,LOSAL,HISAL)



